{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This site contains the project documentation for the <code>pyDFIRRam</code> project, an API to use Volatility</p>"},{"location":"#table-of-contents","title":"Table of contents","text":"<p>The documentation follows the best practice for project documentation as described by Daniele Procida in the Di\u00e1taxis documentation framework and consists of four separate parts:</p> <ol> <li>Tutorials</li> <li>How-To Guides</li> <li>Reference</li> <li>Explanation</li> </ol> <p>Quickly find what you're looking for depending on your use case by looking at the different pages.</p>"},{"location":"explanation/","title":"Explanation","text":"<p>The primary goal of this project is to develop a simple API for Volatility that facilitates orchestration and scripting. This approach allows users to focus on the data itself rather than solely on the output. By improving the representation of data beyond the command line interface (CLI), the project opens up new possibilities for data interpretation and analysis.</p> <p>Through this API, users can engage with the data in more intuitive and insightful ways, enabling a deeper understanding and more thorough examination of the information. This shift from traditional CLI outputs to a more versatile and user-friendly interface is designed to enhance the overall experience and effectiveness of memory analysis tasks.</p>"},{"location":"Usage/installation/","title":"Installation","text":""},{"location":"Usage/installation/#organisation","title":"Organisation","text":""},{"location":"Usage/installation/#quick-installation","title":"Quick installation","text":""},{"location":"Usage/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python</li> <li>Poetry (for dev)</li> <li>pip</li> </ul>"},{"location":"Usage/installation/#from-source","title":"From source","text":"<p>On a standard Linux distribution : <pre><code>git clone https://github.com/pydfir/pydfirram\npoetry shell\npoetry install\n</code></pre></p>"},{"location":"Usage/installation/#from-pip-stable","title":"From pip stable","text":"<pre><code>pip install pydfirram\n</code></pre>"},{"location":"Usage/installation/#from-pip-dev","title":"From pip dev","text":"<pre><code>pip install -i https://test.pypi.org/simple/ pydfirram\n</code></pre>"},{"location":"Usage/linux/","title":"Linux/Mac","text":""},{"location":"Usage/linux/#using-pydfirram-for-linux-or-macos","title":"Using pyDFIRRam for Linux or macOS","text":""},{"location":"Usage/linux/#introduction","title":"Introduction","text":"<p><code>pyDFIRRam</code> is a tool under development aimed at utilizing Volatility plugins for memory forensics on Linux and macOS systems.</p>"},{"location":"Usage/linux/#initial-setup","title":"Initial Setup","text":"<ol> <li>Installation:</li> <li>Ensure Python 3.10 (or compatible version) is installed.</li> <li> <p>Install <code>pyDFIRRam</code> using Poetry or manually. Example:      <pre><code>pip install pydfirram\n</code></pre></p> </li> <li> <p>Setting up a Profile:</p> </li> <li>Currently, there's no direct method via Python interface to add a profile. If you have a profile, place it in the Volatility symbols directory:<ul> <li>For Linux/macOS:    <pre><code>$HOME/.local/lib/python3.10/site-packages/volatility3/symbols/\n</code></pre></li> <li>For Poetry virtual environments:    <pre><code>$HOME/.cache/pypoetry/virtualenvs/pydfirram-qv9SWnlF-py3.10/lib/python3.10/site-packages/volatility3/symbols/\n</code></pre></li> </ul> </li> </ol>"},{"location":"Usage/linux/#using-pydfirram","title":"Using pyDFIRRam","text":"<ol> <li>Creating an Object:</li> <li> <p>Import necessary modules and create an object for your memory dump:      <pre><code>from pydfirram.core.base import Generic, OperatingSystem\nfrom pathlib import Path\n\nos = OperatingSystem.LINUX  # Set to OperatingSystem.MACOS for macOS\ndumpfile = Path(\"dump.raw\")  # Replace with your actual memory dump path\ngeneric = Generic(os, dumpfile)\n</code></pre></p> </li> <li> <p>Listing Available Functions:</p> </li> <li> <p>To list all available Volatility plugins:      <pre><code>generic.get_all_plugins()\n</code></pre></p> </li> <li> <p>Using Plugins:</p> </li> <li> <p>Refer to Volatility plugin documentation for parameters. Example using <code>pslist</code> plugin:      <pre><code>generic.pslist(pid=[4]).to_list()\n</code></pre></p> </li> <li> <p>Formatting Output:</p> </li> <li>The return from Volatility functions provides a <code>Rendering</code> class, allowing customization of output format.</li> </ol>"},{"location":"Usage/linux/#notes","title":"Notes","text":"<ul> <li>Ensure your memory dump file (<code>dump.raw</code> in the example) is correctly specified.</li> <li>Adjust paths and settings based on your specific environment and Python setup.</li> </ul>"},{"location":"Usage/windows/","title":"How to Use pyDFIRRam for Windows","text":"<p>This guide provides a brief and concise demonstration of how to use the pyDFIRRam tool for Windows.</p>"},{"location":"Usage/windows/#introduction","title":"Introduction","text":"<p>Currently, the project is under development. To use the Volatility-related functions for Windows, follow these steps:</p>"},{"location":"Usage/windows/#initial-setup","title":"Initial Setup","text":"<p>First, create an object for your memory dump:</p> <pre><code>from pydfirram.modules.windows import Windows\nfrom pathlib import Path\n\ndump = Path(\"/home/dev/image.dump\")\nwin = Windows(dump)\n</code></pre>"},{"location":"Usage/windows/#listing-available-functions","title":"Listing Available Functions","text":"<p>The available functions are all the Volatility plugins (located in the Volatility plugin path).</p> <p>To list all available functions:</p> <pre><code>win.get_all_plugins()\n</code></pre> <p>You can use this function to retrieve all the plugins.</p>"},{"location":"Usage/windows/#using-parameters","title":"Using Parameters","text":"<p>If you want to use Volatility parameters, refer to the plugin documentation. The parameters expected are generally the same with the same names.</p> <p>For example, to use the <code>pslist</code> plugin with a parameter:</p> <pre><code>win.pslist(pid=4).to_list()\n</code></pre>"},{"location":"Usage/windows/#note","title":"Note","text":"<p>On the return of the Volatility functions, a <code>Rendering</code> class is retrieved. This allows us to format our output as desired.</p>"},{"location":"reference/base/","title":"Base","text":""},{"location":"reference/base/#base","title":"Base","text":"<p>Create generic volatility3 OS wrappers.</p> <p>This module provides a way to interact with Volatility3 plugins in a more abstract way. It allows to automatically get all available plugins for a specific OS and run them with the required arguments.</p> Example <p>The module can be used as follows:</p> <pre><code>$ python3\n&gt;&gt;&gt; from pydfirram.core.base import Generic, OperatingSystem\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; os = OperatingSystem.WINDOWS\n&gt;&gt;&gt; dumpfile = Path(\"tests/data/dump.raw\")\n&gt;&gt;&gt; generic = Generic(os, dumpfile)\n&gt;&gt;&gt; plugin = generic.get_plugin(\"Banners\")\n&gt;&gt;&gt; generic.run_plugin(plugin)\n</code></pre> Example <p>Or it can be used as follow : </p> <pre><code>$ python3\n&gt;&gt;&gt; from pydfirram.core.base import Generic, OperatingSystem\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; os = OperatingSystem.WINDOWS\n&gt;&gt;&gt; dumpfile = Path(\"tests/data/dump.raw\")\n&gt;&gt;&gt; generic = Generic(dumpfile)\n&gt;&gt;&gt; plugin = generic.pslist().to_df()\n&gt;&gt;&gt; print(plugin)\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Context","title":"<code>Context</code>","text":"<p>Context for a volatility3 plugin.</p> <p>Attributes:</p> Name Type Description <code>os</code> <p>OperatingSystem: The operating system.</p> <code>dump_file</code> <p>Path: The dump file path.</p> <code>context</code> <p>volatility3.framework.contexts.Context: The volatility3 context.</p> <code>plugin</code> <p>PluginEntry: The plugin entry.</p> Constants <p>KEY_LAYER_STACKER: str: The layer stacker key. KEY_STACKERS: str: The stackers key. KEY_SINGLE_LOCATION: str: The single location key.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>class Context:\n    \"\"\"Context for a volatility3 plugin.\n\n    Attributes:\n        os: OperatingSystem: The operating system.\n        dump_file: Path: The dump file path.\n        context: volatility3.framework.contexts.Context: The volatility3 context.\n        plugin: PluginEntry: The plugin entry.\n\n    Constants:\n        KEY_LAYER_STACKER: str: The layer stacker key.\n        KEY_STACKERS: str: The stackers key.\n        KEY_SINGLE_LOCATION: str: The single location key.\n    \"\"\"\n\n    KEY_LAYER_STACKER = \"automagic.LayerStacker\"\n    KEY_STACKERS = f\"{KEY_LAYER_STACKER}.stackers\"\n    KEY_SINGLE_LOCATION = f\"{KEY_LAYER_STACKER}.single_location\"\n\n    def __init__(\n        self,\n        operating_system: OperatingSystem,\n        dump_file: Path,\n        plugin: PluginEntry,\n    ):\n        \"\"\"Initializes a context.\n\n        Args:\n            operating_system (OperatingSystem): The operating system.\n            dump_file (Path): The dump file path.\n            plugin (PluginEntry): The plugin entry.\n        \"\"\"\n        self.os = operating_system\n        self.dump_file = dump_file\n        self.context = contexts.Context()\n        self.plugin = plugin\n        self.automag : automagic\n\n    def set_context(self):\n        dump_file_location = self.get_dump_file_location()\n        self.context.config[self.KEY_STACKERS] = self.os_stackers()\n        self.context.config[self.KEY_SINGLE_LOCATION] = dump_file_location\n\n    def set_automagic(self):\n        self.automag = self.automagics()\n\n\n    def build(self) -&gt; interfaces.plugins.PluginInterface:\n        \"\"\"Build a basic context for the provided plugin.\n\n        Returns:\n            interfaces.plugins.PluginInterface: The built plugin interface.\n\n        Raises:\n            VolatilityExceptions.UnsatisfiedException: If the plugin cannot be built.\n        \"\"\"\n        plugin = self.plugin.interface\n        #automagics = self.automagics()\n        #self.set_context()\n        base_config_path = \"plugins\"\n        file_handler = create_file_handler(os.getcwd())\n        try:\n            # Construct the plugin, clever magic figures out how to\n            # fulfill each requirement that might not be fulfilled\n            constructed = construct_plugin(\n                self.context,\n                self.automag,\n                plugin,  # type: ignore\n                base_config_path,\n                None,  # no progress callback for now\n                file_handler,\n            )\n        except VolatilityExceptions.UnsatisfiedException as e:\n            logger.error(f\"Failed to build plugin: {e}\")\n            raise e\n\n        return constructed\n\n    def add_arguments(self,context: contexts.Context(), kwargs: Dict[str, Any]) -&gt; contexts.Context():\n        \"\"\"Handle keyword arguments and set them as context config attributes.\n\n        Args:\n            kwargs (Dict[str, Any]): The keyword arguments.\n\n        Raises:\n            AttributeError: If the attribute does not exist.\n        \"\"\"\n        for k, v in kwargs.items():\n            context.config[k] = v\n        return context\n\n\n    def get_available_automagics(self) -&gt; List[interfaces.automagic.AutomagicInterface]:\n        \"\"\"Returns a list of available volatility3 automagics.\n\n        Returns:\n            List[interfaces.automagic.AutomagicInterface]: A list of available automagics.\n        \"\"\"\n        return automagic.available(self.context)\n\n    def automagics(self) -&gt; List[interfaces.automagic.AutomagicInterface]:\n        \"\"\"Returns a list of volatility3 automagics.\n\n        Returns:\n            List[interfaces.automagic.AutomagicInterface]: A list of automagics.\n\n        Raises:\n            VolatilityExceptions.UnsatisfiedException: If no automagic can be chosen.\n        \"\"\"\n        available_automagics = self.get_available_automagics()\n\n        return automagic.choose_automagic(\n            available_automagics,  # type: ignore\n            self.plugin.interface,  # type: ignore\n        )\n\n    def os_stackers(self) -&gt; List[interfaces.automagic.AutomagicInterface]:\n        \"\"\"Returns a list of stackers for the OS.\n\n        Returns:\n            List[interfaces.automagic.AutomagicInterface]: A list of stackers.\n        \"\"\"\n        return automagic.stacker.choose_os_stackers(self.plugin.interface)\n\n    def get_dump_file_location(self) -&gt; str:\n        \"\"\"Returns the dump file location.\n\n        Returns:\n            str: The dump file location formatted as a URL.\n        \"\"\"\n        return \"file://\" + self.dump_file.absolute().as_posix()\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Context.__init__","title":"<code>__init__(operating_system, dump_file, plugin)</code>","text":"<p>Initializes a context.</p> <p>Parameters:</p> Name Type Description Default <code>operating_system</code> <code>OperatingSystem</code> <p>The operating system.</p> required <code>dump_file</code> <code>Path</code> <p>The dump file path.</p> required <code>plugin</code> <code>PluginEntry</code> <p>The plugin entry.</p> required Source code in <code>pydfirram/core/base.py</code> <pre><code>def __init__(\n    self,\n    operating_system: OperatingSystem,\n    dump_file: Path,\n    plugin: PluginEntry,\n):\n    \"\"\"Initializes a context.\n\n    Args:\n        operating_system (OperatingSystem): The operating system.\n        dump_file (Path): The dump file path.\n        plugin (PluginEntry): The plugin entry.\n    \"\"\"\n    self.os = operating_system\n    self.dump_file = dump_file\n    self.context = contexts.Context()\n    self.plugin = plugin\n    self.automag : automagic\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Context.add_arguments","title":"<code>add_arguments(context, kwargs)</code>","text":"<p>Handle keyword arguments and set them as context config attributes.</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>Dict[str, Any]</code> <p>The keyword arguments.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute does not exist.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def add_arguments(self,context: contexts.Context(), kwargs: Dict[str, Any]) -&gt; contexts.Context():\n    \"\"\"Handle keyword arguments and set them as context config attributes.\n\n    Args:\n        kwargs (Dict[str, Any]): The keyword arguments.\n\n    Raises:\n        AttributeError: If the attribute does not exist.\n    \"\"\"\n    for k, v in kwargs.items():\n        context.config[k] = v\n    return context\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Context.automagics","title":"<code>automagics()</code>","text":"<p>Returns a list of volatility3 automagics.</p> <p>Returns:</p> Type Description <code>List[AutomagicInterface]</code> <p>List[interfaces.automagic.AutomagicInterface]: A list of automagics.</p> <p>Raises:</p> Type Description <code>UnsatisfiedException</code> <p>If no automagic can be chosen.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def automagics(self) -&gt; List[interfaces.automagic.AutomagicInterface]:\n    \"\"\"Returns a list of volatility3 automagics.\n\n    Returns:\n        List[interfaces.automagic.AutomagicInterface]: A list of automagics.\n\n    Raises:\n        VolatilityExceptions.UnsatisfiedException: If no automagic can be chosen.\n    \"\"\"\n    available_automagics = self.get_available_automagics()\n\n    return automagic.choose_automagic(\n        available_automagics,  # type: ignore\n        self.plugin.interface,  # type: ignore\n    )\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Context.build","title":"<code>build()</code>","text":"<p>Build a basic context for the provided plugin.</p> <p>Returns:</p> Type Description <code>PluginInterface</code> <p>interfaces.plugins.PluginInterface: The built plugin interface.</p> <p>Raises:</p> Type Description <code>UnsatisfiedException</code> <p>If the plugin cannot be built.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def build(self) -&gt; interfaces.plugins.PluginInterface:\n    \"\"\"Build a basic context for the provided plugin.\n\n    Returns:\n        interfaces.plugins.PluginInterface: The built plugin interface.\n\n    Raises:\n        VolatilityExceptions.UnsatisfiedException: If the plugin cannot be built.\n    \"\"\"\n    plugin = self.plugin.interface\n    #automagics = self.automagics()\n    #self.set_context()\n    base_config_path = \"plugins\"\n    file_handler = create_file_handler(os.getcwd())\n    try:\n        # Construct the plugin, clever magic figures out how to\n        # fulfill each requirement that might not be fulfilled\n        constructed = construct_plugin(\n            self.context,\n            self.automag,\n            plugin,  # type: ignore\n            base_config_path,\n            None,  # no progress callback for now\n            file_handler,\n        )\n    except VolatilityExceptions.UnsatisfiedException as e:\n        logger.error(f\"Failed to build plugin: {e}\")\n        raise e\n\n    return constructed\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Context.get_available_automagics","title":"<code>get_available_automagics()</code>","text":"<p>Returns a list of available volatility3 automagics.</p> <p>Returns:</p> Type Description <code>List[AutomagicInterface]</code> <p>List[interfaces.automagic.AutomagicInterface]: A list of available automagics.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def get_available_automagics(self) -&gt; List[interfaces.automagic.AutomagicInterface]:\n    \"\"\"Returns a list of available volatility3 automagics.\n\n    Returns:\n        List[interfaces.automagic.AutomagicInterface]: A list of available automagics.\n    \"\"\"\n    return automagic.available(self.context)\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Context.get_dump_file_location","title":"<code>get_dump_file_location()</code>","text":"<p>Returns the dump file location.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The dump file location formatted as a URL.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def get_dump_file_location(self) -&gt; str:\n    \"\"\"Returns the dump file location.\n\n    Returns:\n        str: The dump file location formatted as a URL.\n    \"\"\"\n    return \"file://\" + self.dump_file.absolute().as_posix()\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Context.os_stackers","title":"<code>os_stackers()</code>","text":"<p>Returns a list of stackers for the OS.</p> <p>Returns:</p> Type Description <code>List[AutomagicInterface]</code> <p>List[interfaces.automagic.AutomagicInterface]: A list of stackers.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def os_stackers(self) -&gt; List[interfaces.automagic.AutomagicInterface]:\n    \"\"\"Returns a list of stackers for the OS.\n\n    Returns:\n        List[interfaces.automagic.AutomagicInterface]: A list of stackers.\n    \"\"\"\n    return automagic.stacker.choose_os_stackers(self.plugin.interface)\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Generic","title":"<code>Generic</code>","text":"<p>Generic OS wrapper to be used with volatility3</p> <p>This class provides a way to interact with volatility3 plugins in a more abstract way. It allows to automatically get all available plugins for a specific OS and run them with the required arguments.</p> <p>It aims to be inherited by specific OS wrappers like Windows, Linux or MacOS.</p> <p>Attributes:</p> Name Type Description <code>os</code> <code>OperatingSystem</code> <p>The operating system.</p> <code>plugins</code> <code>List[PluginEntry]</code> <p>The list of plugins.</p> <code>dump_file</code> <code>Path</code> <p>The dump file path.</p> <code>context</code> <code>Context</code> <p>The context.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>class Generic:\n    \"\"\"Generic OS wrapper to be used with volatility3\n\n    This class provides a way to interact with volatility3 plugins in a more\n    abstract way. It allows to automatically get all available plugins for a\n    specific OS and run them with the required arguments.\n\n    It aims to be inherited by specific OS wrappers like Windows, Linux or MacOS.\n\n    Attributes:\n        os (OperatingSystem): The operating system.\n        plugins (List[PluginEntry]): The list of plugins.\n        dump_file (Path): The dump file path.\n        context (Context): The context.\n    \"\"\"\n\n    def __init__(self, operating_system: OperatingSystem, dump_file: Path):\n        \"\"\"Initializes a generic OS.\n\n        Automatically get all available Volatility3 plugins for the OS.\n\n        Args:\n            operating_system (OperatingSystem): The operating system.\n            dump_file (Path): The dump file path.\n\n        Raises:\n            FileNotFoundError: If the dump file does not exist.\n        \"\"\"\n        self.validate_dump_file(dump_file)\n\n        self.os = operating_system\n        self.plugins: List[PluginEntry] = self.get_all_plugins()\n        self.dump_file = dump_file\n        self.context = None\n        self.temp_data = None\n        self.tmp_plugin: PluginEntry = None\n\n        logger.info(f\"Generic OS initialized: {self.os}\")\n\n    def __getattr__(self, key: str,**kwargs: Dict) -&gt; Renderer :\n        \"\"\"\n        Handle attribute access for commands.\n\n        This method is called when an attribute that \n        matches a command name is accessed. It returns a lambda function \n        that calls the __run_commands method with the corresponding key.\n\n        :param key: The attribute name (command name).\n        :type key: str\n        :param args: Positional arguments for the method call.\n        :param kwargs: Keyword arguments for the method call.\n        :return: A class of Renderer that is the result of a lambda\n        function that executes the __run_commands method for the given key.\n        \"\"\"\n        key = key.lower()\n        try:\n            plugin: PluginEntry = self.get_plugin(key)\n        except Exception as exc:\n            raise ValueError(f\"Unable to handle {key}\") from exc\n        def parse_data_function(**kwargs):\n            return Renderer(\n                data= self.run_plugin(plugin,**kwargs)\n                )\n        return parse_data_function\n\n    def run_plugin(self, plugin: PluginEntry, **kwargs: Any) -&gt; Any:\n        \"\"\"Run a volatility3 plugin with the given arguments.\n\n        Args:\n            plugin (PluginEntry): The plugin entry.\n            **kwargs (Any): The keyword arguments.\n\n        Returns:\n            Any: The result of the plugin.\n\n        Raises:\n            ValueError: If the context is not built.\n        \"\"\"\n        self.context = Context(self.os, self.dump_file, plugin) # type: ignore\n        self.context.set_automagic()\n        self.context.set_context()\n        builded_context = self.context.build() # type: ignore\n        if kwargs:\n            runable_context = self.context.add_arguments(builded_context,kwargs)\n        if self.context is None:\n            raise ValueError(\"Context not built.\")\n        return runable_context.run()\n\n    def validate_dump_file(self, dump_file: Path) -&gt; bool:\n        \"\"\"Validate dump file location.\n\n        Args:\n            dump_file (Path): The dump file path.\n\n        Returns:\n            bool: True if the file exists.\n\n        Raises:\n            FileNotFoundError: If the file does not exist.\n        \"\"\"\n        if not dump_file.is_file():\n            raise FileNotFoundError(f\"The file {dump_file} does not exist.\")\n        return True\n\n    def get_plugin(self, name: str) -&gt; PluginEntry:\n        \"\"\"Fetches a plugin by its name from the list of plugins.\n\n        Args:\n            name (str): The plugin name.\n\n        Returns:\n            PluginEntry: The plugin entry.\n\n        Raises:\n            ValueError: If the plugin is not found.\n        \"\"\"\n        name = name.lower()\n        for plugin in self.plugins:\n            if plugin.name == name:\n                return plugin\n\n        raise ValueError(f\"Plugin {name} not found for {self.os}\")\n\n    def get_all_plugins(self) -&gt; List[PluginEntry]:\n        \"\"\"Get all available plugins for the specified OS.\n\n        Returns:\n            List[PluginEntry]: A list of plugins for the specified OS\n            or all available plugins if the OS is not supported.\n\n        Raises:\n            ValueError: If the plugin is not found.\n        \"\"\"\n        plugin_list = self._get_plugins_list()\n        parsed_plugins = self._parse_plugins_list(plugin_list)\n\n        return parsed_plugins\n\n    def _get_plugins_list(self) -&gt; Dict[str, Any]:\n        \"\"\"Get a list of available volatility3 plugins for the OS.\n\n        Returns:\n            Dict[str, Any]: A dictionary of plugins.\n        \"\"\"\n        failures = framework.import_files(plugins, True)\n        if failures:\n            logger.warning(f\"Failed to import some plugins: {failures}\")\n\n        plugin_list = framework.list_plugins()\n\n        return plugin_list\n\n    def _parse_plugins_list(self, plugin_list: Dict[str, Any]) -&gt; List[PluginEntry]:\n        \"\"\"Parse the list of available volatility3 plugins.\n\n        The plugin list is a dictionary where the key is the plugin name\n        and the value is the plugin interface.\n\n        Args:\n            plugin_list (Dict[str, Any]): The plugin list.\n\n        Returns:\n            List[PluginEntry]: A list of PluginEntry.\n        \"\"\"\n        parsed: List[PluginEntry] = list()\n\n        for plugin in plugin_list:\n            interface = plugin_list[plugin]\n            elements = plugin.split(\".\")\n            platform = elements[0]\n            name = elements[-1]\n            name = name.lower()\n            if platform not in OperatingSystem.to_list():\n                type_ = PluginType.GENERIC\n            elif platform == self.os.value:\n                type_ = PluginType.SPECIFIC\n            else:\n                continue\n\n            plugin = PluginEntry(type_, name, interface)\n            parsed.append(plugin)  # type: ignore\n\n        logger.info(f\"Found {len(parsed)} plugins for {self.os}\")\n\n        return parsed\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Generic.__getattr__","title":"<code>__getattr__(key, **kwargs)</code>","text":"<p>Handle attribute access for commands.</p> <p>This method is called when an attribute that  matches a command name is accessed. It returns a lambda function  that calls the __run_commands method with the corresponding key.</p> <p>:param key: The attribute name (command name). :type key: str :param args: Positional arguments for the method call. :param kwargs: Keyword arguments for the method call. :return: A class of Renderer that is the result of a lambda function that executes the __run_commands method for the given key.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def __getattr__(self, key: str,**kwargs: Dict) -&gt; Renderer :\n    \"\"\"\n    Handle attribute access for commands.\n\n    This method is called when an attribute that \n    matches a command name is accessed. It returns a lambda function \n    that calls the __run_commands method with the corresponding key.\n\n    :param key: The attribute name (command name).\n    :type key: str\n    :param args: Positional arguments for the method call.\n    :param kwargs: Keyword arguments for the method call.\n    :return: A class of Renderer that is the result of a lambda\n    function that executes the __run_commands method for the given key.\n    \"\"\"\n    key = key.lower()\n    try:\n        plugin: PluginEntry = self.get_plugin(key)\n    except Exception as exc:\n        raise ValueError(f\"Unable to handle {key}\") from exc\n    def parse_data_function(**kwargs):\n        return Renderer(\n            data= self.run_plugin(plugin,**kwargs)\n            )\n    return parse_data_function\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Generic.__init__","title":"<code>__init__(operating_system, dump_file)</code>","text":"<p>Initializes a generic OS.</p> <p>Automatically get all available Volatility3 plugins for the OS.</p> <p>Parameters:</p> Name Type Description Default <code>operating_system</code> <code>OperatingSystem</code> <p>The operating system.</p> required <code>dump_file</code> <code>Path</code> <p>The dump file path.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the dump file does not exist.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def __init__(self, operating_system: OperatingSystem, dump_file: Path):\n    \"\"\"Initializes a generic OS.\n\n    Automatically get all available Volatility3 plugins for the OS.\n\n    Args:\n        operating_system (OperatingSystem): The operating system.\n        dump_file (Path): The dump file path.\n\n    Raises:\n        FileNotFoundError: If the dump file does not exist.\n    \"\"\"\n    self.validate_dump_file(dump_file)\n\n    self.os = operating_system\n    self.plugins: List[PluginEntry] = self.get_all_plugins()\n    self.dump_file = dump_file\n    self.context = None\n    self.temp_data = None\n    self.tmp_plugin: PluginEntry = None\n\n    logger.info(f\"Generic OS initialized: {self.os}\")\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Generic.get_all_plugins","title":"<code>get_all_plugins()</code>","text":"<p>Get all available plugins for the specified OS.</p> <p>Returns:</p> Type Description <code>List[PluginEntry]</code> <p>List[PluginEntry]: A list of plugins for the specified OS</p> <code>List[PluginEntry]</code> <p>or all available plugins if the OS is not supported.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the plugin is not found.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def get_all_plugins(self) -&gt; List[PluginEntry]:\n    \"\"\"Get all available plugins for the specified OS.\n\n    Returns:\n        List[PluginEntry]: A list of plugins for the specified OS\n        or all available plugins if the OS is not supported.\n\n    Raises:\n        ValueError: If the plugin is not found.\n    \"\"\"\n    plugin_list = self._get_plugins_list()\n    parsed_plugins = self._parse_plugins_list(plugin_list)\n\n    return parsed_plugins\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Generic.get_plugin","title":"<code>get_plugin(name)</code>","text":"<p>Fetches a plugin by its name from the list of plugins.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The plugin name.</p> required <p>Returns:</p> Name Type Description <code>PluginEntry</code> <code>PluginEntry</code> <p>The plugin entry.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the plugin is not found.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def get_plugin(self, name: str) -&gt; PluginEntry:\n    \"\"\"Fetches a plugin by its name from the list of plugins.\n\n    Args:\n        name (str): The plugin name.\n\n    Returns:\n        PluginEntry: The plugin entry.\n\n    Raises:\n        ValueError: If the plugin is not found.\n    \"\"\"\n    name = name.lower()\n    for plugin in self.plugins:\n        if plugin.name == name:\n            return plugin\n\n    raise ValueError(f\"Plugin {name} not found for {self.os}\")\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Generic.run_plugin","title":"<code>run_plugin(plugin, **kwargs)</code>","text":"<p>Run a volatility3 plugin with the given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>plugin</code> <code>PluginEntry</code> <p>The plugin entry.</p> required <code>**kwargs</code> <code>Any</code> <p>The keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The result of the plugin.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the context is not built.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def run_plugin(self, plugin: PluginEntry, **kwargs: Any) -&gt; Any:\n    \"\"\"Run a volatility3 plugin with the given arguments.\n\n    Args:\n        plugin (PluginEntry): The plugin entry.\n        **kwargs (Any): The keyword arguments.\n\n    Returns:\n        Any: The result of the plugin.\n\n    Raises:\n        ValueError: If the context is not built.\n    \"\"\"\n    self.context = Context(self.os, self.dump_file, plugin) # type: ignore\n    self.context.set_automagic()\n    self.context.set_context()\n    builded_context = self.context.build() # type: ignore\n    if kwargs:\n        runable_context = self.context.add_arguments(builded_context,kwargs)\n    if self.context is None:\n        raise ValueError(\"Context not built.\")\n    return runable_context.run()\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.Generic.validate_dump_file","title":"<code>validate_dump_file(dump_file)</code>","text":"<p>Validate dump file location.</p> <p>Parameters:</p> Name Type Description Default <code>dump_file</code> <code>Path</code> <p>The dump file path.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the file exists.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def validate_dump_file(self, dump_file: Path) -&gt; bool:\n    \"\"\"Validate dump file location.\n\n    Args:\n        dump_file (Path): The dump file path.\n\n    Returns:\n        bool: True if the file exists.\n\n    Raises:\n        FileNotFoundError: If the file does not exist.\n    \"\"\"\n    if not dump_file.is_file():\n        raise FileNotFoundError(f\"The file {dump_file} does not exist.\")\n    return True\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.OperatingSystem","title":"<code>OperatingSystem</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Supported operating system.</p> <p>Attributes:</p> Name Type Description <code>WINDOWS</code> <p>Windows OS.</p> <code>LINUX</code> <p>Linux OS.</p> <code>MACOS</code> <p>MacOS OS.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>class OperatingSystem(Enum):\n    \"\"\"Supported operating system.\n\n    Attributes:\n        WINDOWS: Windows OS.\n        LINUX: Linux OS.\n        MACOS: MacOS OS.\n    \"\"\"\n\n    WINDOWS = \"windows\"\n    LINUX = \"linux\"\n    MACOS = \"mac\"\n\n    @staticmethod\n    def to_list() -&gt; List[str]:\n        \"\"\"Returns a list of supported operating systems.\n        Returns:\n            List[str]: List of supported operating systems.\n        \"\"\"\n        return [os.value for os in OperatingSystem]\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.OperatingSystem.to_list","title":"<code>to_list()</code>  <code>staticmethod</code>","text":"<p>Returns a list of supported operating systems. Returns:     List[str]: List of supported operating systems.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>@staticmethod\ndef to_list() -&gt; List[str]:\n    \"\"\"Returns a list of supported operating systems.\n    Returns:\n        List[str]: List of supported operating systems.\n    \"\"\"\n    return [os.value for os in OperatingSystem]\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.PluginEntry","title":"<code>PluginEntry</code>  <code>dataclass</code>","text":"<p>A plugin entry.</p> <p>The interface allows to directly interact with the plugin from volatility3 functions.</p> <p>Attributes:</p> Name Type Description <code>type</code> <code>PluginType</code> <p>PluginType: The plugin type.</p> <code>name</code> <code>str</code> <p>str: The plugin name.</p> <code>interface</code> <code>PluginInterface</code> <p>volatility3.framework.interfaces.plugins.PluginInterface: The plugin interface.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>@dataclass\nclass PluginEntry:\n    \"\"\"A plugin entry.\n\n    The interface allows to directly interact with the plugin from volatility3 functions.\n\n    Attributes:\n        type: PluginType: The plugin type.\n        name: str: The plugin name.\n        interface: volatility3.framework.interfaces.plugins.PluginInterface: The plugin interface.\n    \"\"\"\n\n    type: PluginType\n    name: str\n    interface: interfaces.plugins.PluginInterface\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Returns a string representation of the plugin entry.\"\"\"\n        return f\"PluginEntry({self.type}, {self.name}, {self.interface})\"\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.PluginEntry.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns a string representation of the plugin entry.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Returns a string representation of the plugin entry.\"\"\"\n    return f\"PluginEntry({self.type}, {self.name}, {self.interface})\"\n</code></pre>"},{"location":"reference/base/#pydfirram.core.base.PluginType","title":"<code>PluginType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>A volatiliry3 plugin type.</p> <p>Attributes:</p> Name Type Description <code>GENERIC</code> <p>A generic plugin, can be used with any OS.</p> <code>SPECIFIC</code> <p>An OS-specific plugin.</p> Source code in <code>pydfirram/core/base.py</code> <pre><code>class PluginType(Enum):\n    \"\"\"A volatiliry3 plugin type.\n\n    Attributes:\n        GENERIC: A generic plugin, can be used with any OS.\n        SPECIFIC: An OS-specific plugin.\n    \"\"\"\n\n    GENERIC = 1\n    SPECIFIC = 2\n</code></pre>"},{"location":"reference/handler/","title":"Handler","text":""},{"location":"reference/handler/#handler","title":"Handler","text":"<p>Provides a file handler class that saves files directly to disk.</p> <p>This module provides a file handler class that saves files directly to disk. It is used by the Volatility3 CLI to save files to disk.</p> Example <p>The file handler class can be used as follows:</p> <pre><code>$ python3\n&gt;&gt;&gt; from volatility3.cli import create_file_handler\n&gt;&gt;&gt; file_handler = create_file_handler(\"output\")\n&gt;&gt;&gt; file = file_handler(\"test.txt\")\n&gt;&gt;&gt; file.write(b\"Hello, world!\")\n&gt;&gt;&gt; file.close()\n</code></pre> Todo <ul> <li>For now, this module only provides a file handler class   that saves files directly to disk. In the future, it could   be extended to provide other file handlers as well.</li> </ul>"},{"location":"reference/handler/#pydfirram.core.handler.create_file_handler","title":"<code>create_file_handler(output_dir)</code>","text":"<p>Create a file handler class that saves files directly to disk.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>str</code> <p>The directory where the files should be saved.               If None, raises a TypeError.</p> required <p>Returns:     type: A file handler class that saves files directly to disk.</p> Source code in <code>pydfirram/core/handler.py</code> <pre><code>def create_file_handler(output_dir: Optional[str]) -&gt; type:\n    \"\"\"Create a file handler class that saves files directly to disk.\n\n    Args:\n        output_dir (str): The directory where the files should be saved.\n                          If None, raises a TypeError.\n    Returns:\n        type: A file handler class that saves files directly to disk.\n    \"\"\"\n\n    class CLIFileHandler(interfaces.plugins.FileHandlerInterface):\n        \"\"\"The FileHandler from Volatility3 CLI.\"\"\"\n\n        def _get_final_filename(self) -&gt; str:\n            \"\"\"Gets the final filename for the saved file.\"\"\"\n            if output_dir is None:\n                raise TypeError(\"Output directory is not a string\")\n\n            os.makedirs(output_dir, exist_ok=True)\n            if self.preferred_filename is None:\n                raise TypeError(\"No preferred filename\")\n\n            pref_name_array = self.preferred_filename.split(\".\")\n\n            filename, extension = (\n                os.path.join(output_dir, \".\".join(pref_name_array[:-1])),\n                pref_name_array[-1],\n            )\n            output_filename = f\"{filename}.{extension}\"\n\n            if os.path.exists(output_filename):\n                os.remove(output_filename)\n\n            return output_filename\n\n    class CLIDirectFileHandler(CLIFileHandler):\n        \"\"\"A file handler class that saves files directly to disk.\"\"\"\n\n        def __init__(self, filename: str):\n            fd, temp_name = tempfile.mkstemp(\n                suffix=\".vol3\", prefix=\"tmp_\", dir=output_dir\n            )\n\n            self._file = io.open(fd, mode=\"w+b\")\n            CLIFileHandler.__init__(self, filename)\n\n            for attr in dir(self._file):\n                if not attr.startswith(\"_\") and attr not in [\n                    \"closed\",\n                    \"close\",\n                    \"mode\",\n                    \"name\",\n                ]:\n                    setattr(self, attr, getattr(self._file, attr))\n\n            self._name = temp_name\n\n        def __getattr__(self, item):\n            return getattr(self._file, item)\n\n        @property\n        def closed(self):\n            \"\"\"Returns whether the file is closed.\"\"\"\n            return self._file.closed\n\n        @property\n        def mode(self):\n            \"\"\"Returns the mode of the file.\"\"\"\n            return self._file.mode\n\n        @property\n        def name(self):\n            \"\"\"Returns the name of the file.\"\"\"\n            return self._file.name\n\n        def close(self):\n            \"\"\"Closes and commits the file\n            by moving the temporary file to the correct name.\n            \"\"\"\n            # Don't overcommit\n            if self._file.closed:\n                return\n            self._file.close()\n            output_filename = self._get_final_filename()\n            os.rename(self._name, output_filename)\n\n    return CLIDirectFileHandler\n</code></pre>"},{"location":"reference/renderer/","title":"Renderer","text":""},{"location":"reference/renderer/#renderer","title":"Renderer","text":"<p>This module provides utilities for rendering data in various formats, specifically focusing on rendering Volatility framework data into JSON and pandas DataFrames.</p> <p>Classes:</p> Name Description <code>TreeGrid_to_json</code> <p>A class for rendering Volatility TreeGrid data into JSON format.</p> <code>Renderer</code> <p>A class for rendering data into human-readable formats such as lists,        JSON strings, and pandas DataFrames.</p>"},{"location":"reference/renderer/#pydfirram.core.renderer.Renderer","title":"<code>Renderer</code>","text":"<p>Class for rendering data in various formats.</p> <p>This class provides methods to render data into human-readable formats such as lists, JSON strings, and pandas DataFrames.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Any</code> <p>The input data to be rendered.</p> Source code in <code>pydfirram/core/renderer.py</code> <pre><code>class Renderer:\n    \"\"\"\n    Class for rendering data in various formats.\n\n    This class provides methods to render data into human-readable formats such as lists,\n    JSON strings, and pandas DataFrames.\n\n    Attributes:\n        data (Any): The input data to be rendered.\n    \"\"\"\n\n    def __init__(self, data: Any) -&gt; None:\n        \"\"\"\n        Initialize the Renderer with the provided data.\n\n        Args:\n            data (Any): The input data to be rendered.\n        \"\"\"\n        self.data = data\n\n    def to_list(self) -&gt; Dict:\n        \"\"\"\n        Convert the data to a list format.\n\n        This method attempts to render the input data using the TreeGrid_to_json class,\n        and convert it to a dictionary.\n\n        Returns:\n            Dict: The rendered data in list format.\n\n        Raises:\n            Exception: If rendering the data fails.\n        \"\"\"\n        try:\n            formatted = TreeGrid_to_json().render(self.data)\n            return formatted\n        except Exception as e:\n            logger.error(\"Impossible to render data in dictionary form.\")\n            raise e\n    def file_render(self)-&gt; None:\n        \"\"\"\n        Convert the data to a list format.\n\n        This method attempts to render the input data using the TreeGrid_to_json class,\n        and convert it to a dictionary.\n\n        Returns:\n            Dict: The rendered data in list format.\n\n        Raises:\n            Exception: If rendering the data fails.\n        \"\"\"\n        try:\n            formatted = TreeGrid_to_json().render(self.data)\n        except Exception as e:\n            logger.error(\"Impossible to render data in dictionary form.\")\n            raise e\n\n    def to_json(self) -&gt; str:\n        \"\"\"\n        Convert the data to a JSON string.\n\n        This method first converts the data to a list format, and then serializes it\n        to a JSON string.\n\n        Returns:\n            str: The data serialized as a JSON string.\n\n        Raises:\n            Exception: If converting the data to JSON fails.\n        \"\"\"\n        try:\n            data_as_dict = self.to_list()\n            return dumps(data_as_dict)\n        except Exception as e:\n            logger.error(\"Unable to convert data to JSON.\")\n            raise e\n\n    def to_df(self,max_row: bool = False) -&gt; pd.DataFrame:\n        \"\"\"\n        Convert the data to a pandas DataFrame.\n\n        This method first converts the data to a list format, and then constructs\n        a pandas DataFrame from it.\n\n        Returns:\n            pd.DataFrame: The data as a pandas DataFrame.\n\n        Raises:\n            Exception: If rendering the data as a DataFrame fails.\n        \"\"\"\n        try:\n            data_as_dict = self.to_list()\n            if max_row:\n                pd.set_option('display.max_rows', None)\n                pd.set_option('display.max_columns', None)\n            return pd.DataFrame(data_as_dict)\n        except Exception as e:\n            logger.error(\"Data cannot be rendered as a DataFrame.\")\n            raise e\n</code></pre>"},{"location":"reference/renderer/#pydfirram.core.renderer.Renderer.__init__","title":"<code>__init__(data)</code>","text":"<p>Initialize the Renderer with the provided data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>The input data to be rendered.</p> required Source code in <code>pydfirram/core/renderer.py</code> <pre><code>def __init__(self, data: Any) -&gt; None:\n    \"\"\"\n    Initialize the Renderer with the provided data.\n\n    Args:\n        data (Any): The input data to be rendered.\n    \"\"\"\n    self.data = data\n</code></pre>"},{"location":"reference/renderer/#pydfirram.core.renderer.Renderer.file_render","title":"<code>file_render()</code>","text":"<p>Convert the data to a list format.</p> <p>This method attempts to render the input data using the TreeGrid_to_json class, and convert it to a dictionary.</p> <p>Returns:</p> Name Type Description <code>Dict</code> <code>None</code> <p>The rendered data in list format.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If rendering the data fails.</p> Source code in <code>pydfirram/core/renderer.py</code> <pre><code>def file_render(self)-&gt; None:\n    \"\"\"\n    Convert the data to a list format.\n\n    This method attempts to render the input data using the TreeGrid_to_json class,\n    and convert it to a dictionary.\n\n    Returns:\n        Dict: The rendered data in list format.\n\n    Raises:\n        Exception: If rendering the data fails.\n    \"\"\"\n    try:\n        formatted = TreeGrid_to_json().render(self.data)\n    except Exception as e:\n        logger.error(\"Impossible to render data in dictionary form.\")\n        raise e\n</code></pre>"},{"location":"reference/renderer/#pydfirram.core.renderer.Renderer.to_df","title":"<code>to_df(max_row=False)</code>","text":"<p>Convert the data to a pandas DataFrame.</p> <p>This method first converts the data to a list format, and then constructs a pandas DataFrame from it.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: The data as a pandas DataFrame.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If rendering the data as a DataFrame fails.</p> Source code in <code>pydfirram/core/renderer.py</code> <pre><code>def to_df(self,max_row: bool = False) -&gt; pd.DataFrame:\n    \"\"\"\n    Convert the data to a pandas DataFrame.\n\n    This method first converts the data to a list format, and then constructs\n    a pandas DataFrame from it.\n\n    Returns:\n        pd.DataFrame: The data as a pandas DataFrame.\n\n    Raises:\n        Exception: If rendering the data as a DataFrame fails.\n    \"\"\"\n    try:\n        data_as_dict = self.to_list()\n        if max_row:\n            pd.set_option('display.max_rows', None)\n            pd.set_option('display.max_columns', None)\n        return pd.DataFrame(data_as_dict)\n    except Exception as e:\n        logger.error(\"Data cannot be rendered as a DataFrame.\")\n        raise e\n</code></pre>"},{"location":"reference/renderer/#pydfirram.core.renderer.Renderer.to_json","title":"<code>to_json()</code>","text":"<p>Convert the data to a JSON string.</p> <p>This method first converts the data to a list format, and then serializes it to a JSON string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The data serialized as a JSON string.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If converting the data to JSON fails.</p> Source code in <code>pydfirram/core/renderer.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"\n    Convert the data to a JSON string.\n\n    This method first converts the data to a list format, and then serializes it\n    to a JSON string.\n\n    Returns:\n        str: The data serialized as a JSON string.\n\n    Raises:\n        Exception: If converting the data to JSON fails.\n    \"\"\"\n    try:\n        data_as_dict = self.to_list()\n        return dumps(data_as_dict)\n    except Exception as e:\n        logger.error(\"Unable to convert data to JSON.\")\n        raise e\n</code></pre>"},{"location":"reference/renderer/#pydfirram.core.renderer.Renderer.to_list","title":"<code>to_list()</code>","text":"<p>Convert the data to a list format.</p> <p>This method attempts to render the input data using the TreeGrid_to_json class, and convert it to a dictionary.</p> <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>The rendered data in list format.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If rendering the data fails.</p> Source code in <code>pydfirram/core/renderer.py</code> <pre><code>def to_list(self) -&gt; Dict:\n    \"\"\"\n    Convert the data to a list format.\n\n    This method attempts to render the input data using the TreeGrid_to_json class,\n    and convert it to a dictionary.\n\n    Returns:\n        Dict: The rendered data in list format.\n\n    Raises:\n        Exception: If rendering the data fails.\n    \"\"\"\n    try:\n        formatted = TreeGrid_to_json().render(self.data)\n        return formatted\n    except Exception as e:\n        logger.error(\"Impossible to render data in dictionary form.\")\n        raise e\n</code></pre>"},{"location":"reference/renderer/#pydfirram.core.renderer.TreeGrid_to_json","title":"<code>TreeGrid_to_json</code>","text":"<p>               Bases: <code>CLIRenderer</code></p> Source code in <code>pydfirram/core/renderer.py</code> <pre><code>class TreeGrid_to_json(text_renderer.CLIRenderer):\n    _type_renderers = {\n        format_hints.HexBytes: lambda x: text_renderer.quoted_optional(\n            text_renderer.hex_bytes_as_text\n        )(x),\n        interfaces.renderers.Disassembly: lambda x: text_renderer.quoted_optional(\n            text_renderer.display_disassembly\n        )(x),\n        format_hints.MultiTypeData: lambda x: text_renderer.quoted_optional(\n            text_renderer.multitypedata_as_text\n        )(x),\n        bytes: lambda x: text_renderer.optional(\n            lambda x: \" \".join([f\"{b:02x}\" for b in x])\n        )(x),\n        datetime.datetime: lambda x: x.isoformat()\n        if not isinstance(x, interfaces.renderers.BaseAbsentValue)\n        else None,\n        \"default\": lambda x: x,\n    }\n\n    name = \"JSON\"\n    structured_output = True\n\n    def get_render_options(self) -&gt; List[interfaces.renderers.RenderOption]:\n        \"\"\"\n        Get render options.\n        \"\"\"\n        pass\n\n    def render(self, grid: interfaces.renderers.TreeGrid) -&gt; Dict:\n        \"\"\"\n        Render the TreeGrid to JSON format.\n\n        Args:\n            grid (interfaces.renderers.TreeGrid): The TreeGrid to render.\n\n        Returns:\n            Dict: The JSON representation of the TreeGrid.\n        \"\"\"\n        final_output: Tuple[\n            Dict[str, List[interfaces.renderers.TreeNode]],\n            List[interfaces.renderers.TreeNode],\n        ] = ({}, [])\n        def visitor(\n            node: interfaces.renderers.TreeNode,\n            accumulator: Tuple[Dict[str, Dict[str, Any]], List[Dict[str, Any]]],\n        ) -&gt; Tuple[Dict[str, Dict[str, Any]], List[Dict[str, Any]]]:\n\n            \"\"\"\n            A visitor function to process each node in the TreeGrid.\n\n            Args:\n                node (interfaces.renderers.TreeNode): The current node being visited.\n                accumulator (Tuple[Dict[str, Dict[str, Any]], List[Dict[str, Any]]]):\n                    The accumulator containing the accumulated results.\n\n            Returns:\n                Tuple[Dict[str, Dict[str, Any]], List[Dict[str, Any]]]: The updated accumulator.\n            \"\"\"\n            acc_map, final_tree = accumulator\n            node_dict: Dict[str, Any] = {\"__children\": []}\n\n            for column_index in range(len(grid.columns)):\n                column = grid.columns[column_index]\n                renderer = self._type_renderers.get(\n                    column.type, self._type_renderers[\"default\"]\n                )\n                data = renderer(list(node.values)[column_index])\n                if isinstance(data, interfaces.renderers.BaseAbsentValue):\n                    data = None\n                node_dict[column.name] = data\n\n            if node.parent:\n                acc_map[node.parent.path][\"__children\"].append(node_dict)\n            else:\n                final_tree.append(node_dict)\n            acc_map[node.path] = node_dict\n            return acc_map, final_tree\n\n        if not grid.populated:\n            grid.populate(visitor, final_output)\n        else:\n            grid.visit(node=None, function=visitor, initial_accumulator=final_output)\n        return final_output[1]\n</code></pre>"},{"location":"reference/renderer/#pydfirram.core.renderer.TreeGrid_to_json.get_render_options","title":"<code>get_render_options()</code>","text":"<p>Get render options.</p> Source code in <code>pydfirram/core/renderer.py</code> <pre><code>def get_render_options(self) -&gt; List[interfaces.renderers.RenderOption]:\n    \"\"\"\n    Get render options.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/renderer/#pydfirram.core.renderer.TreeGrid_to_json.render","title":"<code>render(grid)</code>","text":"<p>Render the TreeGrid to JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>TreeGrid</code> <p>The TreeGrid to render.</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>The JSON representation of the TreeGrid.</p> Source code in <code>pydfirram/core/renderer.py</code> <pre><code>def render(self, grid: interfaces.renderers.TreeGrid) -&gt; Dict:\n    \"\"\"\n    Render the TreeGrid to JSON format.\n\n    Args:\n        grid (interfaces.renderers.TreeGrid): The TreeGrid to render.\n\n    Returns:\n        Dict: The JSON representation of the TreeGrid.\n    \"\"\"\n    final_output: Tuple[\n        Dict[str, List[interfaces.renderers.TreeNode]],\n        List[interfaces.renderers.TreeNode],\n    ] = ({}, [])\n    def visitor(\n        node: interfaces.renderers.TreeNode,\n        accumulator: Tuple[Dict[str, Dict[str, Any]], List[Dict[str, Any]]],\n    ) -&gt; Tuple[Dict[str, Dict[str, Any]], List[Dict[str, Any]]]:\n\n        \"\"\"\n        A visitor function to process each node in the TreeGrid.\n\n        Args:\n            node (interfaces.renderers.TreeNode): The current node being visited.\n            accumulator (Tuple[Dict[str, Dict[str, Any]], List[Dict[str, Any]]]):\n                The accumulator containing the accumulated results.\n\n        Returns:\n            Tuple[Dict[str, Dict[str, Any]], List[Dict[str, Any]]]: The updated accumulator.\n        \"\"\"\n        acc_map, final_tree = accumulator\n        node_dict: Dict[str, Any] = {\"__children\": []}\n\n        for column_index in range(len(grid.columns)):\n            column = grid.columns[column_index]\n            renderer = self._type_renderers.get(\n                column.type, self._type_renderers[\"default\"]\n            )\n            data = renderer(list(node.values)[column_index])\n            if isinstance(data, interfaces.renderers.BaseAbsentValue):\n                data = None\n            node_dict[column.name] = data\n\n        if node.parent:\n            acc_map[node.parent.path][\"__children\"].append(node_dict)\n        else:\n            final_tree.append(node_dict)\n        acc_map[node.path] = node_dict\n        return acc_map, final_tree\n\n    if not grid.populated:\n        grid.populate(visitor, final_output)\n    else:\n        grid.visit(node=None, function=visitor, initial_accumulator=final_output)\n    return final_output[1]\n</code></pre>"},{"location":"reference/test/","title":"Test Documentation","text":""},{"location":"reference/test/#project-structure","title":"Project Structure","text":"<p>The project is organized as follows: <pre><code>.\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 config.py\n\u251c\u2500\u2500 data\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 dump.raw\n\u251c\u2500\u2500 test_core_base.py\n\u251c\u2500\u2500 test_core_rendering.py\n\u2514\u2500\u2500 test_volatility_windows_function.py\n</code></pre></p>"},{"location":"reference/test/#files-description","title":"Files Description","text":"<ul> <li> <p>config.py   This file contains configuration settings. You need to set the path of your dump file here before running the tests.</p> </li> <li> <p>test_core_base.py   This script tests the core functionalities used in <code>pydfirram/core/base.py</code>.</p> </li> <li> <p>test_core_rendering.py   This script tests the core functionalities used in <code>pydfirram/core/renderer.py</code>.</p> </li> <li> <p>test_volatility_windows_function.py   This script tests all(Not All configuration an plugins for the moment) plugins of Volatility.</p> </li> </ul>"},{"location":"reference/test/#test-data","title":"Test Data","text":"<ul> <li>data/dump.raw   This is where your test dump file should be located.</li> </ul>"},{"location":"reference/test/#running-the-tests","title":"Running the Tests","text":""},{"location":"reference/test/#prerequisites","title":"Prerequisites","text":"<ol> <li> <p>Download the Windows XP image from the Volatility Foundation:    Win XP Image.</p> </li> <li> <p>Extract the downloaded image and place it in the <code>data</code> directory. Rename it to <code>dump.raw</code>.</p> </li> </ol>"},{"location":"reference/test/#configuration","title":"Configuration","text":"<ol> <li>Open <code>config.py</code>.</li> <li>Set the path of your dump file in the configuration.</li> </ol>"},{"location":"reference/test/#running-the-tests_1","title":"Running the Tests","text":"<p>To run the tests, use the following command: <pre><code>pytest\n</code></pre></p>"},{"location":"reference/test/#notes","title":"Notes","text":"<ul> <li>The current tests only support Windows architectures. Linux architectures are not supported yet.</li> </ul>"},{"location":"reference/utils/","title":"Utils","text":""},{"location":"reference/utils/#utils","title":"Utils","text":"<p>This module provides utilities for hashing files.</p> <p>Functions:</p> Name Description <code>get_hash</code> <p>Path) -&gt; str: Calculates and returns the SHA-256 hash of the specified file.</p>"},{"location":"reference/utils/#pydfirram.core.utils.get_hash","title":"<code>get_hash(path)</code>","text":"<p>Get the hash of a file.</p> <p>This method opens the specified file in binary mode and calculates the SHA-256  hash by traversing the file inblocks of 4096 bytes. The hash is updated at each iteration to include the contents of the processed block.</p> <p>Once the entire file has been processed, the method returns the SHA-256 hash  value in hexadecimal format.</p> <p>Note: This method is intended for internal use by the specific code and must not be called directly from other parts of the code.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the file.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Hash of the file.</p> Source code in <code>pydfirram/core/utils.py</code> <pre><code>def get_hash(path: Path) -&gt; str:\n    \"\"\"\n    Get the hash of a file.\n\n    This method opens the specified file in binary mode and calculates the SHA-256 \n    hash by traversing the file inblocks of 4096 bytes. The hash is updated at each iteration\n    to include the contents of the processed block.\n\n    Once the entire file has been processed, the method returns the SHA-256 hash \n    value in hexadecimal format.\n\n    Note: This method is intended for internal use by the specific code and must not be called\n    directly from other parts of the code.\n\n    Args:\n        path (Path): Path to the file.\n\n    Returns:\n        str: Hash of the file.\n    \"\"\"\n    with open(path, \"rb\") as f:\n        hash_obj = hashlib.sha256()\n        for chunk in iter(lambda: f.read(4096), b\"\"):\n            hash_obj.update(chunk)\n\n        return hash_obj.hexdigest()\n</code></pre>"},{"location":"reference/windows/","title":"Windows","text":""},{"location":"reference/windows/#windows","title":"Windows","text":"<p>Create generic volatility3 OS wrappers.</p> <p>This module provides a way to interact with Volatility3 plugins in a more abstract way. It allows to automatically get all available plugins for a specific OS and run them with the required arguments.</p> Example <p>The module can be used as follows:</p> <pre><code>$ python3\n&gt;&gt;&gt; from pydfirram.modules.windows import Windows\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; dumpfile = Path(\"tests/data/dump.raw\")\n&gt;&gt;&gt; generic = Windows(dumpfile)\n&gt;&gt;&gt; plugin = generic.pslist().to_list()\n</code></pre> <p>OR :     $ python3     &gt;&gt;&gt; from pydfirram.modules.windows import Windows     &gt;&gt;&gt; from pathlib import Path     &gt;&gt;&gt; dumpfile = Path(\"tests/data/dump.raw\")     &gt;&gt;&gt; generic = Windows(dumpfile)     &gt;&gt;&gt; plugin = generic.pslist(pid=[4]).to_df()     &gt;&gt;&gt; print(plugin)</p>"},{"location":"reference/windows/#pydfirram.modules.windows.Windows","title":"<code>Windows</code>","text":"<p>               Bases: <code>Generic</code></p> <p>A wrapper class for utilizing Windows-specific functionalities around the base methods.</p> <p>This class serves as a simplified interface for interacting with Windows operating system dumps.  It inherits from the Generic class and initializes with Windows as the operating system.</p>"},{"location":"reference/windows/#pydfirram.modules.windows.Windows--attributes","title":"Attributes:","text":"<p>dumpfile : str     The path to the memory dump file.</p>"},{"location":"reference/windows/#pydfirram.modules.windows.Windows--methods","title":"Methods:","text":"<p>init(dumpfile)     Initializes the Windows class with the given dump file.</p> Source code in <code>pydfirram/modules/windows.py</code> <pre><code>class Windows(Generic):\n    \"\"\"\n    A wrapper class for utilizing Windows-specific functionalities around the base methods.\n\n    This class serves as a simplified interface for interacting with Windows operating system dumps. \n    It inherits from the Generic class and initializes with Windows as the operating system.\n\n    Attributes:\n    -----------\n    dumpfile : str\n        The path to the memory dump file.\n\n    Methods:\n    --------\n    __init__(dumpfile)\n        Initializes the Windows class with the given dump file.\n    \"\"\"\n    def __init__(self, dumpfile):\n        \"\"\"\n        Initializes the Windows class.\n\n        Parameters:\n        -----------\n        dumpfile : str\n            The path to the memory dump file.\n\n        Example:\n        --------\n        &gt;&gt;&gt; windows = Windows(\"path/to/dump.raw\": Path)\n        \"\"\"\n        self.dump_files = dumpfile\n        super().__init__(OperatingSystem.WINDOWS, dumpfile)\n\n    def _set_argument(self,context, prefix, kwargs):\n        for k, v in kwargs.items():\n            print(k,v)\n            context.config[prefix+k] = v\n        return context\n\n    def dumpfiles(self,**kwargs) -&gt; None:\n        \"\"\"\n            Dump memory files based on provided parameters.\n\n            This method utilizes the \"dumpfiles\" plugin to create memory dumps from a \n            Windows operating system context. The memory dumps can be filtered based \n            on the provided arguments. If no parameters are provided, the method will\n            dump the entire system by default.\n\n            Parameters:\n            -----------\n            physaddr : int, optional\n                The physical address offset for the memory dump.\n            virtaddr : int, optional\n                The virtual address offset for the memory dump.\n            pid : int, optional\n                The process ID for which the memory dump should be generated.\n\n            Notes:\n            ------\n            - The method sets up the context with the operating system and dump files.\n            - Automagic and context settings are configured before building the context.\n            - If additional keyword arguments are provided, they are added as arguments to the context.\n            - The resulting context is executed and rendered to a file using the Renderer class.\n            - If no parameters are provided, the method will dump the entire system by default.\n\n            Returns:\n            --------\n            None\n            \"\"\"\n        plugin = self.get_plugin(\"dumpfiles\")\n        context = Context(OperatingSystem.WINDOWS, self.dump_files, plugin) # type: ignore\n        context.set_automagic()\n        context.set_context()\n        builded_context = context.build()\n        if kwargs:\n            runable_context = context.add_arguments(builded_context,kwargs)\n        Renderer(runable_context.run()).file_render()\n</code></pre>"},{"location":"reference/windows/#pydfirram.modules.windows.Windows.__init__","title":"<code>__init__(dumpfile)</code>","text":"<p>Initializes the Windows class.</p>"},{"location":"reference/windows/#pydfirram.modules.windows.Windows.__init__--parameters","title":"Parameters:","text":"<p>dumpfile : str     The path to the memory dump file.</p>"},{"location":"reference/windows/#pydfirram.modules.windows.Windows.__init__--example","title":"Example:","text":"<p>windows = Windows(\"path/to/dump.raw\": Path)</p> Source code in <code>pydfirram/modules/windows.py</code> <pre><code>def __init__(self, dumpfile):\n    \"\"\"\n    Initializes the Windows class.\n\n    Parameters:\n    -----------\n    dumpfile : str\n        The path to the memory dump file.\n\n    Example:\n    --------\n    &gt;&gt;&gt; windows = Windows(\"path/to/dump.raw\": Path)\n    \"\"\"\n    self.dump_files = dumpfile\n    super().__init__(OperatingSystem.WINDOWS, dumpfile)\n</code></pre>"},{"location":"reference/windows/#pydfirram.modules.windows.Windows.dumpfiles","title":"<code>dumpfiles(**kwargs)</code>","text":"<p>Dump memory files based on provided parameters.</p> <p>This method utilizes the \"dumpfiles\" plugin to create memory dumps from a  Windows operating system context. The memory dumps can be filtered based  on the provided arguments. If no parameters are provided, the method will dump the entire system by default.</p>"},{"location":"reference/windows/#pydfirram.modules.windows.Windows.dumpfiles--parameters","title":"Parameters:","text":"<p>physaddr : int, optional     The physical address offset for the memory dump. virtaddr : int, optional     The virtual address offset for the memory dump. pid : int, optional     The process ID for which the memory dump should be generated.</p>"},{"location":"reference/windows/#pydfirram.modules.windows.Windows.dumpfiles--notes","title":"Notes:","text":"<ul> <li>The method sets up the context with the operating system and dump files.</li> <li>Automagic and context settings are configured before building the context.</li> <li>If additional keyword arguments are provided, they are added as arguments to the context.</li> <li>The resulting context is executed and rendered to a file using the Renderer class.</li> <li>If no parameters are provided, the method will dump the entire system by default.</li> </ul>"},{"location":"reference/windows/#pydfirram.modules.windows.Windows.dumpfiles--returns","title":"Returns:","text":"<p>None</p> Source code in <code>pydfirram/modules/windows.py</code> <pre><code>def dumpfiles(self,**kwargs) -&gt; None:\n    \"\"\"\n        Dump memory files based on provided parameters.\n\n        This method utilizes the \"dumpfiles\" plugin to create memory dumps from a \n        Windows operating system context. The memory dumps can be filtered based \n        on the provided arguments. If no parameters are provided, the method will\n        dump the entire system by default.\n\n        Parameters:\n        -----------\n        physaddr : int, optional\n            The physical address offset for the memory dump.\n        virtaddr : int, optional\n            The virtual address offset for the memory dump.\n        pid : int, optional\n            The process ID for which the memory dump should be generated.\n\n        Notes:\n        ------\n        - The method sets up the context with the operating system and dump files.\n        - Automagic and context settings are configured before building the context.\n        - If additional keyword arguments are provided, they are added as arguments to the context.\n        - The resulting context is executed and rendered to a file using the Renderer class.\n        - If no parameters are provided, the method will dump the entire system by default.\n\n        Returns:\n        --------\n        None\n        \"\"\"\n    plugin = self.get_plugin(\"dumpfiles\")\n    context = Context(OperatingSystem.WINDOWS, self.dump_files, plugin) # type: ignore\n    context.set_automagic()\n    context.set_context()\n    builded_context = context.build()\n    if kwargs:\n        runable_context = context.add_arguments(builded_context,kwargs)\n    Renderer(runable_context.run()).file_render()\n</code></pre>"}]}